---
layout:     post
title:      高速缓存的别名和同名
subtitle:   cache alias and homonyms
date:       2023-08-17
author:     icecube
header-img: img/bluelinux.jpg
catalog: true
tags:
    - cache
---
### 高速缓存
三种映射方式
* 直接相连映射
* 全相连映射
* 组相连映射

三种缓存匹配方式
* VIVT  虚拟索引虚拟标记
* VIPT  虚拟索引物理标记
* PIPT  物理索引物理标记

地址高位部分是标记，中间位置是索引，低位部分是cache行内地址。  
索引就是用于查找cache行匹配的行号，和行内地址共同定位cache中的数据。

根据索引找到cache行，就可以获取到cache行中保存的标记。  
标记匹配成功则代表高速缓存命中。

### 别名问题
**别名(cache alias)问题的本质是多个虚拟地址有可能对应同一个物理地址**  
比如进程和进程之间，进程和内核之间,  
因而同一个物理地址的数据就可能在cache有多个备份，如果多个备份的数据出现不一致的情况，就可能发生逻辑错误。  

比如进程A和进程B通过共享内存交互通信，进程A的VA和进程B的VB都映射到PA。  
当VA写入数据时，高速缓存命中会写入数据到缓存行，同时也会写入PA（透写或者回写），  
这会导致B进程的VB对应的高速换存行中的数据变得过时。这就会导致问题。

只有虚拟地址索引的设计方案（VIVT和VIPT）才可能会导致别名问题。  
说可能是因为虚拟地址索引并不是必然会产生别名问题，需要一定的条件才会产生。  

虚拟页号和页内偏移的划分边界取决于页面大小。  
如果页面大小为4KB，则页内偏移为12位；若果页面大小为16KB，则页内偏移为14位。  

标记与索引的划分取决于cache的总大小（对于直接映射而言是总大小，对于组相连映射则取决于一路cache的总大小）。  
如果一路cache的大小为16KB，则索引需要14位；如果一路cache的总大小为64KB，则索引需要16位。  

当cache匹配划分边界所产生的索引位数超过地址转换划分边界所产生的页内偏移位数时，就会存在别名问题。  

* 如果索引位数没有超过页内偏移数，那么虚拟地址索引和物理地址索引必定具有相同的含义，
在地址转换过程中，虚拟地址和物理地址的页内偏移值是相等的，  
因为给定的索引数值在一路cache中的位置是固定的，只有一个cache行对应该索引值，所以不存在别名问题。

* 而如果索引位数超过了内存偏移数，那么一路cache大小将超过页面大小，  
如果一个物理地址确实对应了多个虚拟地址，那么就很有可能在cache中存在多个备份，  
产生别名问题（当然，如果硬件能够做到保证多个备份的数据一致性，那么别名问题就不会导致程序逻辑问题）。

假如一路cache大小为16KB，页面大小为8KB  
所有页按照虚拟页号编号，偶数号页为红页，奇数号页为蓝色页。     
那么，根据虚拟地址索引，必然是所有红页都映射在cache低半部分（0-127组），  
所有蓝页都映射到cache的高半部分(128-255组)。   
其结果就是，只有当一个物理页同时具有红色虚拟页和蓝色虚拟页的多个映射时  
才会真正产生别名。  
只要保证一个物理页只具有一种颜色，别名问题就解决了。  
因此，一路cache是页面大小的多少倍，就需要多少种颜色。  

假定`PAGE_SIZE == 8KB`
假定 L1-Dcache 大小为64KB，cache行大小64B，采用4路组相连映射，一路大小为16KB  
即 `2^2(路) * 2^8(组) * 2^6(cache line size) == 64KB`  

组件采用直接相连映射，组内采用全相连映射  

那么tag占据60位，index占据8位，cache line size占据6位  
一路cache可以缓存2个PAGE的数据  

采用虚拟索引的匹配方式，两个不同的虚拟地址有可能映射到同一个物理地址  
索引最大偏移数13bit超过了页内偏移数12bit  

![](https://raw.githubusercontent.com/l3b2w1/l3b2w1.github.io/master/img/2023-08-17-vitual-index.png)

### 同名问题
**同名（homonyms）问题指的是相同的虚拟地址对应不同的物理地址。**  
因为操作系统的进程中会存在很多相同的虚拟地址。  
而这些相同的虚拟地址在经过MMU转换后得到不同的物理地址，所以就产生了同名问题。

同名问题常出现在进程切换的场景中。  
当一个进程切换到另一个进程时，若新进程使用虚拟地址访问高速缓存，    
就会访问旧进程遗留在高速缓存中的数据，这些数据对于新进程来说是无用的并且错误的。    
新进程的运行就会出现问题。    

解决办法是在进程切换时使所有高速缓存行都失效，这样就可以保证新进程得到干净的高速缓存。    
同样，需要使TLB无效，因为新进程在切换后会得到一个旧进程的TLB，    
里面存放的是旧进程虚拟地址到物理地址的转换结果，这些对新进程来说是无用的，因此需要把TLB清空。  
而采用物理地址索引的高速缓存则可以避免同名问题，因为索引域的值是通过MMU转换地址得到的。  

综上所述   
别名问题指的是多个不同的虚拟地址映射到同一个物理地址的现象   
同名问题指的是同一个虚拟地址映射到不同的物理地址的现象  

PIPT不存在同名问题和别名问题  
相比于VIVT（虚拟索引虚拟标记）和VIPT（虚拟索引物理标记）模式，    
PIPT的优点是不会出现虚拟地址映射到相同缓存索引的情况，   
因为物理地址的唯一性保证了每个地址在缓存中的位置是固定的，不会引发别名问题。  
因为一个物理地址是唯一的，物理索引也是唯一的，只会定位到一路cache中的固定位置。    
再加上物理标记也是唯一的，比对标记之后要么命中，要么缺失，不会导致别名和同名问题。

### 参考
《RISC-V体系结构编程与实践》  
《用芯探核-基于龙芯的linux内核探索解析》    
